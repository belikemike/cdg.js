/*
 *  cdg.js - a CD+G player for the web, based upon CD+Graphics Magic HTML5 CD+G Player
 *  (http://cdgmagic.sourceforge.net/html5_cdgplayer/). Visit project for full license
 *  information and documentation: https://github.com/willprescott/cdg.js
 */

{"version":3,"sources":["cdg.js"],"names":["define","CDGDecoder","canvasEl","borderEl","reset_cdg_state","internal_current_pack","internal_border_index","clear_palette","clear_vram","clear_dirty_blocks","get_current_pack","redraw_canvas","internal_border_dirty","internal_screen_dirty","internal_border_div","style","backgroundColor","palette_index_to_rgb_tuple","render_screen_to_rgb","internal_rgba_context","putImageData","internal_rgba_imagedata","local_context","local_rgba_imagedata","local_dirty","internal_dirty_blocks","local_fontwidth","CDG_ENUM","FONT_WIDTH","local_fontheight","FONT_HEIGHT","blk","y_blk","NUM_X_FONTS","x_blk","render_block_to_rgb","decode_packs","cdg_file_data","playback_position","curr_pack","start_offset","curr_command","charCodeAt","TV_GRAPHICS","this_pack","slice","curr_instruction","MEMORY_PRESET","proc_MEMORY_PRESET","BORDER_PRESET","proc_BORDER_PRESET","LOAD_CLUT_LO","LOAD_CLUT_HI","proc_LOAD_CLUT","COPY_FONT","XOR_FONT","proc_WRITE_FONT","SCROLL_PRESET","SCROLL_COPY","proc_DO_SCROLL","requested_index","internal_palette","fill_line_with_palette_index","adjusted_value","total_palette_entries","PALETTE_ENTRIES","idx","color_index","local_vram","internal_vram","total_vram_size","length","packed_line_value","pxl","local_rgba","data","local_pal","vis_width","vis_height","VISIBLE_HEIGHT","vram_loc","rgb_loc","curr_rgb","curr_line_indices","y_pxl","x_pxl","x_start","y_start","vram_inc","vram_end","VISIBLE_WIDTH","rgb_inc","cdg_pack","new_border_index","local_palette","pal_offset","pal_inc","temp_idx","temp_rgb","temp_entry","active_channels","subcode_channel","xor_var","x_location","y_location","start_pixel","current_indexes","current_row","temp_pxl","y_inc","pix_pos","direction","copy_flag","color","proc_VRAM_HSCROLL","proc_VRAM_VSCROLL","x_src","y_src","buf","line_color","dst_idx","src_idx","offscreen_size","Array","VRAM_HEIGHT","NUM_Y_FONTS","getContext","createImageData","this","CDGPlayer","containerId","initOptions","handleCDGHttpRequest","cdgHttpRequest","readyState","status","Error","cdgData","responseText","handleAudioError","audioPlayer","error","error_result","code","updatePlayPosition","position_to_play","play_position","Math","floor","currentTime","current_pack","cdgDecoder","setCDGInterval","cdgIntervalID","setInterval","clearCDGInterval","clearInterval","play","pause","stop","parseOptions","options","isArray","audioFilePrefix","cdgFilePrefix","mediaPath","defaults","audioFormat","cdgFileExtension","audioTypes","loadTrack","trackInfo","XMLHttpRequest","onreadystatechange","open","setRequestHeader","send","audioSourceElement","document","createElement","type","src","appendChild","load","init","containerEl","getElementById","id","className","width","height","offsetWidth","controls","showControls","autoplay","addEventListener","mp3","ogg"],"mappings":"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xB,EAAA,KACApB,EAAA,KACAI,EAAA,KACAc,EAAA,IA6JAiC,GAAAtD,EAAAC,GAGAH,KAAA0C,UAAAA,EACA1C,KAAA6B,KAAAA,EACA7B,KAAA+B,KAAAA,EACA/B,KAAA8B,MAAAA,EAGA,OACA0B,KAAA,SAAAtD,EAAAC,GACA,MAAA,IAAAF,GAAAC,EAAAC,OAKAnI,OAAA,SAAA;AAnrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"cdg.js","sourcesContent":["/*\r\n *  This library is heavily based upon CD+Graphics Magic HTML5 CD+G Player\r\n *  (http://cdgmagic.sourceforge.net/html5_cdgplayer/), which\r\n *  is distributed under the following licence conditions:\r\n *\r\n *  CD+Graphics Magic is free software: you can redistribute it and/or\r\n *  modify it under the terms of the GNU General Public License as\r\n *  published by the Free Software Foundation, either version 2 of the\r\n *  License, or (at your option) any later version.\r\n *\r\n *  CD+Graphics Magic is distributed in the hope that it will be useful,\r\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *  GNU General Public License for more details.\r\n *\r\n *  You should have received a copy of the GNU General Public License\r\n *  along with CD+Graphics Magic. If not, see <http://www.gnu.org/licenses/>.\r\n */\r\n\r\n/*global define document setInterval clearInterval XMLHttpRequest */\r\n\r\ndefine(\"cdg\", [], function() {\r\n    \"use strict\";\r\n\r\n    function CDGDecoder(canvasEl, borderEl) {\r\n\r\n        var CDG_ENUM = {\r\n            VRAM_HEIGHT: 216,    // Height of VRAM, in pixels.\r\n            VISIBLE_WIDTH: 288,    // Width (or pitch) of visible screen, in pixels.\r\n            VISIBLE_HEIGHT: 192,    // Height of visible screen, in pixels.\r\n            FONT_WIDTH: 6,    // Width of  one \"font\" (or block).\r\n            FONT_HEIGHT: 12,    // Height of one \"font\" (or block).\r\n            NUM_X_FONTS: 50,    // Number of horizontal fonts contained in VRAM.\r\n            NUM_Y_FONTS: 18,    // Number of vertical fonts contained in VRAM.\r\n            PALETTE_ENTRIES: 16,    // Number of CLUT palette entries.\r\n            TV_GRAPHICS: 0x09,    // 50x18 (48x16) 16 color TV graphics mode.\r\n            MEMORY_PRESET: 0x01,    // Set all VRAM to palette index.\r\n            BORDER_PRESET: 0x02,    // Set border to palette index.\r\n            LOAD_CLUT_LO: 0x1E,    // Load Color Look Up Table index 0 through 7.\r\n            LOAD_CLUT_HI: 0x1F,    // Load Color Look Up Table index 8 through 15.\r\n            COPY_FONT: 0x06,    // Copy 12x6 pixel font to screen.\r\n            XOR_FONT: 0x26,    // XOR 12x6 pixel font with existing VRAM values.\r\n            SCROLL_PRESET: 0x14,    // Update scroll offset, copying if 0x20 or 0x10.\r\n            SCROLL_COPY: 0x18     // Update scroll offset, setting color if 0x20 or 0x10.\r\n        };\r\n\r\n        var internal_border_div = borderEl; // DIV element behind graphics canvas.\r\n        var internal_rgba_context = canvasEl.getContext(\"2d\");  // 2D context of canvas element.\r\n        var internal_rgba_imagedata = internal_rgba_context.createImageData(CDG_ENUM.VISIBLE_WIDTH, CDG_ENUM.VISIBLE_HEIGHT);  // 288x192 image data.\r\n        var internal_palette = new Array(CDG_ENUM.PALETTE_ENTRIES);                     // Array containing the 16 RGB palette entries.\r\n        var internal_vram = new Array(CDG_ENUM.NUM_X_FONTS * CDG_ENUM.VRAM_HEIGHT);  // Array used for graphics VRAM.\r\n\r\n        var internal_border_index = 0x00;  // The current border palette index.\r\n        var internal_current_pack = 0x00;  // The current playback position.\r\n\r\n        var internal_border_dirty = false;            // State variable used to determine if the background DIV needs updated.\r\n        var internal_screen_dirty = false;            // State variable used to determine if a full screen update is needed.\r\n        var internal_dirty_blocks = new Array(900);  // Array used to determine if a given font/block has changed.\r\n\r\n        // Reset all the CDG state variables back to initial values.\r\n        function reset_cdg_state() {\r\n            internal_current_pack = 0x00;\r\n            internal_border_index = 0x00;\r\n            clear_palette();\r\n            clear_vram(0x00);\r\n            clear_dirty_blocks();\r\n        }\r\n\r\n        function get_current_pack() {\r\n            return internal_current_pack;\r\n        }\r\n\r\n        function redraw_canvas() {\r\n            // If the border color has changed, then update the background div color.\r\n            if (internal_border_dirty || internal_screen_dirty) {\r\n                internal_border_div.style.backgroundColor = palette_index_to_rgb_tuple(internal_border_index);\r\n                internal_border_dirty = false;\r\n            }\r\n\r\n            // If the screen is dirty, then it needs a full update.\r\n            if (internal_screen_dirty) {\r\n                render_screen_to_rgb();\r\n                internal_screen_dirty = false;\r\n                clear_dirty_blocks();\r\n                internal_rgba_context.putImageData(internal_rgba_imagedata, 0, 0);\r\n            }\r\n            else {\r\n                var local_context = internal_rgba_context;\r\n                var local_rgba_imagedata = internal_rgba_imagedata;\r\n                var local_dirty = internal_dirty_blocks;\r\n                var local_fontwidth = CDG_ENUM.FONT_WIDTH;\r\n                var local_fontheight = CDG_ENUM.FONT_HEIGHT;\r\n                var blk = 0x00;\r\n                for (var y_blk = 1; y_blk <= 16; ++y_blk) {\r\n                    blk = y_blk * CDG_ENUM.NUM_X_FONTS + 1;\r\n                    for (var x_blk = 1; x_blk <= 48; ++x_blk) {\r\n                        if (local_dirty[blk]) {\r\n                            render_block_to_rgb(x_blk, y_blk);\r\n                            local_context.putImageData(local_rgba_imagedata, 0, 0,\r\n                                (x_blk - 1) * local_fontwidth,\r\n                                (y_blk - 1) * local_fontheight,\r\n                                local_fontwidth,\r\n                                local_fontheight);\r\n                            local_dirty[blk] = 0x00;\r\n                        }\r\n                        ++blk;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Decode to pack playback_position, using cdg_file_data.\r\n        function decode_packs(cdg_file_data, playback_position) {\r\n            for (var curr_pack = internal_current_pack; curr_pack < playback_position; curr_pack++) {\r\n                var start_offset = curr_pack * 24;\r\n                var curr_command = cdg_file_data.charCodeAt(start_offset) & 0x3F;\r\n                if (curr_command == CDG_ENUM.TV_GRAPHICS) {\r\n                    // Slice the file array down to a single pack array.\r\n                    var this_pack = cdg_file_data.slice(start_offset, start_offset + 24);\r\n                    // Pluck out the graphics instruction.\r\n                    var curr_instruction = this_pack.charCodeAt(1) & 0x3F;\r\n                    // Perform the instruction action.\r\n                    switch (curr_instruction) {\r\n                        case CDG_ENUM.MEMORY_PRESET:\r\n                            proc_MEMORY_PRESET(this_pack);\r\n                            break;\r\n                        case CDG_ENUM.BORDER_PRESET:\r\n                            proc_BORDER_PRESET(this_pack);\r\n                            break;\r\n\r\n                        case CDG_ENUM.LOAD_CLUT_LO:\r\n                        case CDG_ENUM.LOAD_CLUT_HI:\r\n                            proc_LOAD_CLUT(this_pack);\r\n                            break;\r\n\r\n                        case CDG_ENUM.COPY_FONT:\r\n                        case CDG_ENUM.XOR_FONT:\r\n                            proc_WRITE_FONT(this_pack);\r\n                            break;\r\n\r\n                        case CDG_ENUM.SCROLL_PRESET:\r\n                        case CDG_ENUM.SCROLL_COPY:\r\n                            proc_DO_SCROLL(this_pack);\r\n                            break;\r\n                    }\r\n                }\r\n            }\r\n            internal_current_pack = playback_position;\r\n        }\r\n\r\n        // Convenience function to return the string \"rgb(r,g,b)\" CSS style tuple of a palette index.\r\n        function palette_index_to_rgb_tuple(requested_index) {\r\n            return \"rgb(\" + (internal_palette[requested_index] >> 16 & 0xFF) + \",\" + (internal_palette[requested_index] >> 8 & 0xFF) + \",\" + (internal_palette[requested_index] >> 0 & 0xFF) + \")\";\r\n        }\r\n\r\n        // Convenience function to return a line of special packed palette values.\r\n        function fill_line_with_palette_index(requested_index) {\r\n            var adjusted_value = requested_index;           // Pixel 0\r\n            adjusted_value |= (requested_index << 4);  // Pixel 1\r\n            adjusted_value |= (requested_index << 8);  // Pixel 2\r\n            adjusted_value |= (requested_index << 12);  // Pixel 3\r\n            adjusted_value |= (requested_index << 16);  // Pixel 4\r\n            adjusted_value |= (requested_index << 20);  // Pixel 5\r\n            return adjusted_value;\r\n        }\r\n\r\n        // Reset the state of all font/blocks to clean.\r\n        function clear_dirty_blocks() {\r\n            for (var blk = 0; blk < 900; blk++) {\r\n                internal_dirty_blocks[blk] = 0x00;\r\n            }\r\n        }\r\n\r\n        // Reset all the palette RGB values to black.\r\n        function clear_palette() {\r\n            var total_palette_entries = CDG_ENUM.PALETTE_ENTRIES;\r\n            for (var idx = 0; idx < total_palette_entries; idx++) {\r\n                internal_palette[idx] = 0x00;\r\n            }\r\n        }\r\n\r\n        // Set all the VRAM index values to requested index.\r\n        function clear_vram(color_index) {\r\n            var local_vram = internal_vram;\r\n            var total_vram_size = local_vram.length;\r\n            var packed_line_value = fill_line_with_palette_index(color_index);\r\n            for (var pxl = 0; pxl < total_vram_size; pxl++) {\r\n                local_vram[pxl] = packed_line_value;\r\n            }\r\n            internal_screen_dirty = true;\r\n        }\r\n\r\n        function render_screen_to_rgb() {\r\n            var local_rgba = internal_rgba_imagedata.data;\r\n            var local_pal = internal_palette;\r\n            var local_vram = internal_vram;\r\n            var vis_width = 48;\r\n            var vis_height = CDG_ENUM.VISIBLE_HEIGHT;\r\n\r\n            var vram_loc = 601;   // Offset into VRAM array.\r\n            var rgb_loc = 0x00;  // Offset into RGBA array.\r\n            var curr_rgb = 0x00;          // RGBA value of current pixel.\r\n            var curr_line_indices = 0x00; // Packed font row index values.\r\n\r\n            for (var y_pxl = 0; y_pxl < vis_height; ++y_pxl) {\r\n                for (var x_pxl = 0; x_pxl < vis_width; ++x_pxl) {\r\n                    curr_line_indices = local_vram[vram_loc++];              // Get the current line segment indices.\r\n                    curr_rgb = local_pal[(curr_line_indices >> 0) & 0x0F];  // Get the RGB value for pixel 0.\r\n                    local_rgba[rgb_loc++] = (curr_rgb >> 16) & 0xFF;        // Set red value for pixel 0.\r\n                    local_rgba[rgb_loc++] = (curr_rgb >> 8) & 0xFF;        // Set green value for pixel 0.\r\n                    local_rgba[rgb_loc++] = (curr_rgb >> 0) & 0xFF;        // Set blue value for pixel 0.\r\n                    local_rgba[rgb_loc++] = 0xFF;                            // Set alpha value (fully opaque) for pixel 0.\r\n                    curr_rgb = local_pal[(curr_line_indices >> 4) & 0x0F];  // Get the RGB value for pixel 1.\r\n                    local_rgba[rgb_loc++] = (curr_rgb >> 16) & 0xFF;        // Set red value for pixel 1.\r\n                    local_rgba[rgb_loc++] = (curr_rgb >> 8) & 0xFF;        // Set green value for pixel 1.\r\n                    local_rgba[rgb_loc++] = (curr_rgb >> 0) & 0xFF;        // Set blue value for pixel 1.\r\n                    local_rgba[rgb_loc++] = 0xFF;                            // Set alpha value (fully opaque) for pixel 1.\r\n                    curr_rgb = local_pal[(curr_line_indices >> 8) & 0x0F];  // Get the RGB value for pixel 2.\r\n                    local_rgba[rgb_loc++] = (curr_rgb >> 16) & 0xFF;        // Set red value for pixel 2.\r\n                    local_rgba[rgb_loc++] = (curr_rgb >> 8) & 0xFF;        // Set green value for pixel 2.\r\n                    local_rgba[rgb_loc++] = (curr_rgb >> 0) & 0xFF;        // Set blue value for pixel 2.\r\n                    local_rgba[rgb_loc++] = 0xFF;                            // Set alpha value (fully opaque) for pixel 2.\r\n                    curr_rgb = local_pal[(curr_line_indices >> 12) & 0x0F];  // Get the RGB value for pixel 3.\r\n                    local_rgba[rgb_loc++] = (curr_rgb >> 16) & 0xFF;        // Set red value for pixel 3.\r\n                    local_rgba[rgb_loc++] = (curr_rgb >> 8) & 0xFF;        // Set green value for pixel 3.\r\n                    local_rgba[rgb_loc++] = (curr_rgb >> 0) & 0xFF;        // Set blue value for pixel 3.\r\n                    local_rgba[rgb_loc++] = 0xFF;                            // Set alpha value (fully opaque) for pixel 3.\r\n                    curr_rgb = local_pal[(curr_line_indices >> 16) & 0x0F];  // Get the RGB value for pixel 4.\r\n                    local_rgba[rgb_loc++] = (curr_rgb >> 16) & 0xFF;        // Set red value for pixel 4.\r\n                    local_rgba[rgb_loc++] = (curr_rgb >> 8) & 0xFF;        // Set green value for pixel 4.\r\n                    local_rgba[rgb_loc++] = (curr_rgb >> 0) & 0xFF;        // Set blue value for pixel 4.\r\n                    local_rgba[rgb_loc++] = 0xFF;                            // Set alpha value (fully opaque) for pixel 4.\r\n                    curr_rgb = local_pal[(curr_line_indices >> 20) & 0x0F];  // Get the RGB value for pixel 5.\r\n                    local_rgba[rgb_loc++] = (curr_rgb >> 16) & 0xFF;        // Set red value for pixel 5.\r\n                    local_rgba[rgb_loc++] = (curr_rgb >> 8) & 0xFF;        // Set green value for pixel 5.\r\n                    local_rgba[rgb_loc++] = (curr_rgb >> 0) & 0xFF;        // Set blue value for pixel 5.\r\n                    local_rgba[rgb_loc++] = 0xFF;                            // Set alpha value (fully opaque) for pixel 5.\r\n                    // Or, instead, index 0 could be set transparent to show background image/video.\r\n                    // Alternately, SET_TRANSPARENT instruction could be implemented to set 6bit transparency.\r\n                    // Unfortunately, I don't think many (any?) discs bother to set it :-/...\r\n                }\r\n                vram_loc += 2;  // Skip the offscreen font blocks.\r\n            }\r\n        }\r\n\r\n        function render_block_to_rgb(x_start, y_start) {\r\n            var local_rgba = internal_rgba_imagedata.data;\r\n            var local_pal = internal_palette;\r\n            var local_vram = internal_vram;\r\n\r\n            var vram_loc = (y_start * CDG_ENUM.NUM_X_FONTS * CDG_ENUM.FONT_HEIGHT) + x_start;  // Offset into VRAM array.\r\n            var vram_inc = CDG_ENUM.NUM_X_FONTS;\r\n            var vram_end = vram_loc + (CDG_ENUM.NUM_X_FONTS * CDG_ENUM.FONT_HEIGHT);       // VRAM location to end.\r\n            var rgb_loc = (y_start - 1) * CDG_ENUM.FONT_HEIGHT * CDG_ENUM.VISIBLE_WIDTH; // Row start.\r\n            rgb_loc += (x_start - 1) * CDG_ENUM.FONT_WIDTH;                           // Column start\r\n            rgb_loc *= 4;                                                             // RGBA, 1 pxl = 4 bytes.\r\n            var rgb_inc = (CDG_ENUM.VISIBLE_WIDTH - CDG_ENUM.FONT_WIDTH) * 4;\r\n            var curr_rgb = 0x00;          // RGBA value of current pixel.\r\n            var curr_line_indices = 0x00; // Packed font row index values.\r\n\r\n            while (vram_loc < vram_end) {\r\n                curr_line_indices = local_vram[vram_loc];                // Get the current line segment indices.\r\n                curr_rgb = local_pal[(curr_line_indices >> 0) & 0x0F];  // Get the RGB value for pixel 0.\r\n                local_rgba[rgb_loc++] = (curr_rgb >> 16) & 0xFF;        // Set red value for pixel 0.\r\n                local_rgba[rgb_loc++] = (curr_rgb >> 8) & 0xFF;        // Set green value for pixel 0.\r\n                local_rgba[rgb_loc++] = (curr_rgb >> 0) & 0xFF;        // Set blue value for pixel 0.\r\n                local_rgba[rgb_loc++] = 0xFF;                            // Set alpha value (fully opaque) for pixel 0.\r\n                curr_rgb = local_pal[(curr_line_indices >> 4) & 0x0F];  // Get the RGB value for pixel 1.\r\n                local_rgba[rgb_loc++] = (curr_rgb >> 16) & 0xFF;        // Set red value for pixel 1.\r\n                local_rgba[rgb_loc++] = (curr_rgb >> 8) & 0xFF;        // Set green value for pixel 1.\r\n                local_rgba[rgb_loc++] = (curr_rgb >> 0) & 0xFF;        // Set blue value for pixel 1.\r\n                local_rgba[rgb_loc++] = 0xFF;                            // Set alpha value (fully opaque) for pixel 1.\r\n                curr_rgb = local_pal[(curr_line_indices >> 8) & 0x0F];  // Get the RGB value for pixel 2.\r\n                local_rgba[rgb_loc++] = (curr_rgb >> 16) & 0xFF;        // Set red value for pixel 2.\r\n                local_rgba[rgb_loc++] = (curr_rgb >> 8) & 0xFF;        // Set green value for pixel 2.\r\n                local_rgba[rgb_loc++] = (curr_rgb >> 0) & 0xFF;        // Set blue value for pixel 2.\r\n                local_rgba[rgb_loc++] = 0xFF;                            // Set alpha value (fully opaque) for pixel 2.\r\n                curr_rgb = local_pal[(curr_line_indices >> 12) & 0x0F];  // Get the RGB value for pixel 3.\r\n                local_rgba[rgb_loc++] = (curr_rgb >> 16) & 0xFF;        // Set red value for pixel 3.\r\n                local_rgba[rgb_loc++] = (curr_rgb >> 8) & 0xFF;        // Set green value for pixel 3.\r\n                local_rgba[rgb_loc++] = (curr_rgb >> 0) & 0xFF;        // Set blue value for pixel 3.\r\n                local_rgba[rgb_loc++] = 0xFF;                            // Set alpha value (fully opaque) for pixel 3.\r\n                curr_rgb = local_pal[(curr_line_indices >> 16) & 0x0F];  // Get the RGB value for pixel 4.\r\n                local_rgba[rgb_loc++] = (curr_rgb >> 16) & 0xFF;        // Set red value for pixel 4.\r\n                local_rgba[rgb_loc++] = (curr_rgb >> 8) & 0xFF;        // Set green value for pixel 4.\r\n                local_rgba[rgb_loc++] = (curr_rgb >> 0) & 0xFF;        // Set blue value for pixel 4.\r\n                local_rgba[rgb_loc++] = 0xFF;                            // Set alpha value (fully opaque) for pixel 4.\r\n                curr_rgb = local_pal[(curr_line_indices >> 20) & 0x0F];  // Get the RGB value for pixel 5.\r\n                local_rgba[rgb_loc++] = (curr_rgb >> 16) & 0xFF;        // Set red value for pixel 5.\r\n                local_rgba[rgb_loc++] = (curr_rgb >> 8) & 0xFF;        // Set green value for pixel 5.\r\n                local_rgba[rgb_loc++] = (curr_rgb >> 0) & 0xFF;        // Set blue value for pixel 5.\r\n                local_rgba[rgb_loc++] = 0xFF;                            // Set alpha value (fully opaque) for pixel 5.\r\n                // Or, instead, index 0 could be set transparent to show background image/video.\r\n                // Alternately, SET_TRANSPARENT instruction could be implemented to set 6bit transparency.\r\n                // Unfortunately, I don't think many (any?) discs bother to set it :-/...\r\n                vram_loc += vram_inc; // Move to the first column of the next row of this font block in VRAM.\r\n                rgb_loc += rgb_inc;  // Move to the first column of the next row of this font block in RGB pixels.\r\n            }\r\n        }\r\n\r\n        function proc_BORDER_PRESET(cdg_pack) {\r\n            // NOTE: The \"border\" is actually a DIV element, which can be very expensive to change in some browsers.\r\n            // This somewhat bizarre check ensures that the DIV is only touched if the actual RGB color is different,\r\n            // but the border index variable is always set... A similar check is also performed during palette update.\r\n            var new_border_index = cdg_pack.charCodeAt(4) & 0x3F; // Get the border index from subcode.\r\n            // Check if the new border **RGB** color is different from the old one.\r\n            if (internal_palette[new_border_index] != internal_palette[internal_border_index]) {\r\n                internal_border_dirty = true;                     // Border needs updating.\r\n            }\r\n            internal_border_index = new_border_index;             // Set the new index.\r\n        }\r\n\r\n        function proc_MEMORY_PRESET(cdg_pack) {\r\n            clear_vram(cdg_pack.charCodeAt(4) & 0x3F);\r\n        }\r\n\r\n\r\n        function proc_LOAD_CLUT(cdg_pack) {\r\n            var local_palette = internal_palette;\r\n            // If instruction is 0x1E then 8*0=0, if 0x1F then 8*1=8 for offset.\r\n            var pal_offset = (cdg_pack.charCodeAt(1) & 0x01) * 8;\r\n            // Step through the eight color indices, setting the RGB values.\r\n            for (var pal_inc = 0; pal_inc < 8; pal_inc++) {\r\n                var temp_idx = pal_inc + pal_offset;\r\n                var temp_rgb = 0x00000000;\r\n                var temp_entry = 0x00000000;\r\n                // Set red.\r\n                temp_entry = (cdg_pack.charCodeAt(pal_inc * 2 + 4) & 0x3C) >> 2;\r\n                temp_rgb |= (temp_entry * 17) << 16;\r\n                // Set green.\r\n                temp_entry = ((cdg_pack.charCodeAt(pal_inc * 2 + 4) & 0x03) << 2) | ((cdg_pack.charCodeAt(pal_inc * 2 + 5) & 0x30) >> 4);\r\n                temp_rgb |= (temp_entry * 17) << 8;\r\n                // Set blue.\r\n                temp_entry = cdg_pack.charCodeAt(pal_inc * 2 + 5) & 0x0F;\r\n                temp_rgb |= (temp_entry * 17) << 0;\r\n                // Put the full RGB value into the index position, but only if it's different.\r\n                if (temp_rgb != local_palette[temp_idx]) {\r\n                    local_palette[temp_idx] = temp_rgb;\r\n                    internal_screen_dirty = true; // The colors are now different, so we need to update the whole screen.\r\n                    if (temp_idx == internal_border_index) {\r\n                        internal_border_dirty = true;\r\n                    } // The border color has changed.\r\n                }\r\n            }\r\n        }\r\n\r\n        function proc_WRITE_FONT(cdg_pack) {\r\n            var local_vram = internal_vram;\r\n            var local_dirty = internal_dirty_blocks;\r\n            // Hacky hack to play channels 0 and 1 only... Ideally, there should be a function and user option to get/set.\r\n            var active_channels = 0x03;\r\n            // First, get the channel...\r\n            var subcode_channel = ((cdg_pack.charCodeAt(4) & 0x30) >> 2) | ((cdg_pack.charCodeAt(5) & 0x30) >> 4);\r\n            var xor_var = cdg_pack.charCodeAt(1) & 0x20;\r\n            // Then see if we should display it.\r\n            if ((active_channels >> subcode_channel) && 0x01) {\r\n                var x_location = cdg_pack.charCodeAt(7) & 0x3F; // Get horizontal font location.\r\n                var y_location = cdg_pack.charCodeAt(6) & 0x1F; // Get vertical font location.\r\n\r\n                // Verify we're not going to overrun the boundaries (i.e. bad data from a scratched disc).\r\n                if ((x_location <= 49) && (y_location <= 17)) {\r\n                    var start_pixel = y_location * 600 + x_location; // Location of first pixel of this font in linear VRAM.\r\n                    // NOTE: Profiling indicates charCodeAt() uses ~80% of the CPU consumed for this function.\r\n                    // Caching these values reduces that to a negligible amount.\r\n                    var current_indexes = [(cdg_pack.charCodeAt(4) & 0x0F), (cdg_pack.charCodeAt(5) & 0x0F)]; // Current colors.\r\n                    var current_row = 0x00; // Subcode byte for current pixel row.\r\n                    var temp_pxl = 0x00; // Decoded and packed 4bit pixel index values of current row.\r\n                    for (var y_inc = 0; y_inc < 12; y_inc++) {\r\n                        var pix_pos = y_inc * 50 + start_pixel;      // Location of the first pixel of this row in linear VRAM.\r\n                        current_row = cdg_pack.charCodeAt(y_inc + 8);  // Get the subcode byte for the current row.\r\n                        temp_pxl = (current_indexes[(current_row >> 5) & 0x01] << 0);\r\n                        temp_pxl |= (current_indexes[(current_row >> 4) & 0x01] << 4);\r\n                        temp_pxl |= (current_indexes[(current_row >> 3) & 0x01] << 8);\r\n                        temp_pxl |= (current_indexes[(current_row >> 2) & 0x01] << 12);\r\n                        temp_pxl |= (current_indexes[(current_row >> 1) & 0x01] << 16);\r\n                        temp_pxl |= (current_indexes[(current_row >> 0) & 0x01] << 20);\r\n                        if (xor_var) {\r\n                            local_vram[pix_pos] ^= temp_pxl;\r\n                        } else {\r\n                            local_vram[pix_pos] = temp_pxl;\r\n                        }\r\n                    } // End of Y loop.\r\n                    // Mark this block as needing an update.\r\n                    local_dirty[y_location * 50 + x_location] = 0x01;\r\n                } // End of location check.\r\n            } // End of channel check.\r\n        }\r\n\r\n        function proc_DO_SCROLL(cdg_pack) {\r\n            var direction,\r\n                copy_flag = (cdg_pack.charCodeAt(1) & 0x08) >> 3,\r\n                color = cdg_pack.charCodeAt(4) & 0x0F;             // Color index to use for preset type.\r\n\r\n            // Process horizontal commands.\r\n            if ((direction = ((cdg_pack.charCodeAt(5) & 0x30) >> 4))) {\r\n                proc_VRAM_HSCROLL(direction, copy_flag, color);\r\n            }\r\n            // Process vertical commands.\r\n            if ((direction = ((cdg_pack.charCodeAt(6) & 0x30) >> 4))) {\r\n                proc_VRAM_VSCROLL(direction, copy_flag, color);\r\n            }\r\n            internal_screen_dirty = true;  // Entire screen needs to be redrawn.\r\n        }\r\n\r\n        function proc_VRAM_HSCROLL(direction, copy_flag, color) {\r\n            var x_src,\r\n                y_src,\r\n                y_start,\r\n                buf = 0,\r\n                line_color = fill_line_with_palette_index(color),\r\n                local_vram = internal_vram;\r\n            if (direction == 0x02) {\r\n                // Step through the lines one at a time...\r\n                for (y_src = 0; y_src < (50 * 216); y_src += 50) {\r\n                    y_start = y_src;\r\n                    buf = local_vram[y_start];\r\n                    for (x_src = y_start + 1; x_src < y_start + 50; x_src++) {\r\n                        local_vram[x_src - 1] = local_vram[x_src];\r\n                    }\r\n                    if (copy_flag) {\r\n                        local_vram[y_start + 49] = buf;\r\n                    } else {\r\n                        local_vram[y_start + 49] = line_color;\r\n                    }\r\n                }\r\n            }\r\n            else if (direction == 0x01) {\r\n                // Step through the lines on at a time.\r\n                for (y_src = 0; y_src < (50 * 216); y_src += 50) {\r\n                    // Copy the last six lines to the buffer.\r\n                    y_start = y_src;\r\n                    buf = local_vram[y_start + 49];\r\n                    for (x_src = y_start + 48; x_src >= y_start; x_src--) {\r\n                        local_vram[x_src + 1] = local_vram[x_src];\r\n                    }\r\n                    if (copy_flag) {\r\n                        local_vram[y_start] = buf;\r\n                    } else {\r\n                        local_vram[y_start] = line_color;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        function proc_VRAM_VSCROLL(direction, copy_flag, color) {\r\n            var dst_idx,\r\n                src_idx,\r\n                offscreen_size = CDG_ENUM.NUM_X_FONTS * CDG_ENUM.FONT_HEIGHT,\r\n                buf = new Array(offscreen_size),\r\n                line_color = fill_line_with_palette_index(color),\r\n                local_vram = internal_vram;\r\n            if (direction == 0x02) {\r\n                dst_idx = 0;  // Buffer destination starts at 0.\r\n                // Copy the top 300x12 pixels into the buffer.\r\n                for (src_idx = 0; src_idx < offscreen_size; src_idx++) {\r\n                    buf[dst_idx++] = local_vram[src_idx];\r\n                }\r\n                dst_idx = 0; // Destination starts at the first line.\r\n                for (src_idx = offscreen_size; src_idx < (50 * 216); src_idx++) {\r\n                    local_vram[dst_idx++] = local_vram[src_idx];\r\n                }\r\n                dst_idx = (CDG_ENUM.NUM_X_FONTS * 204); // Destination begins at line 204.\r\n                if (copy_flag) {\r\n                    for (src_idx = 0; src_idx < offscreen_size; src_idx++) {\r\n                        local_vram[dst_idx++] = buf[src_idx];\r\n                    }\r\n                }\r\n                else {\r\n                    for (src_idx = 0; src_idx < offscreen_size; src_idx++) {\r\n                        local_vram[dst_idx++] = line_color;\r\n                    }\r\n                }\r\n            }\r\n            else if (direction == 0x01) {\r\n                dst_idx = 0;  // Buffer destination starts at 0.\r\n                // Copy the bottom 300x12 pixels into the buffer.\r\n                for (src_idx = (50 * 204); src_idx < (50 * 216); src_idx++) {\r\n                    buf[dst_idx++] = local_vram[src_idx];\r\n                }\r\n                for (src_idx = (50 * 204) - 1; src_idx > 0; src_idx--) {\r\n                    local_vram[src_idx + offscreen_size] = local_vram[src_idx];\r\n                }\r\n                if (copy_flag) {\r\n                    for (src_idx = 0; src_idx < offscreen_size; src_idx++) {\r\n                        local_vram[src_idx] = buf[src_idx];\r\n                    }\r\n                }\r\n                else {\r\n                    for (src_idx = 0; src_idx < offscreen_size; src_idx++) {\r\n                        local_vram[src_idx] = line_color;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Bind the public functions to member variables.\r\n        this.get_current_pack = get_current_pack;\r\n        this.reset_cdg_state = reset_cdg_state;\r\n        this.redraw_canvas = redraw_canvas;\r\n        this.decode_packs = decode_packs;\r\n        this.reset_cdg_state();\r\n    }\r\n\r\n    function CDGPlayer(containerId, initOptions) {\r\n\r\n        var defaults = {\r\n                mediaPath: '',\r\n                audioFormat: 'mp3',\r\n                cdgFileExtension: 'cdg'\r\n            },\r\n            audioTypes = {\r\n                mp3: 'audio/mpeg; codecs=\"mp3\"',\r\n                ogg: 'audio/ogg; codecs=\"vorbis\"'\r\n            },\r\n            audioPlayer = null,\r\n            audioSourceElement = null,\r\n            cdgIntervalID = null,\r\n            cdgHttpRequest = null,\r\n            cdgData = null,\r\n            cdgDecoder = null;\r\n\r\n        function handleCDGHttpRequest() {\r\n            if (!cdgHttpRequest) {\r\n                return;\r\n            }\r\n            if (cdgHttpRequest.readyState == 4) {\r\n                if (cdgHttpRequest.status != 200) {\r\n                    throw new Error('CDG file failed to load');\r\n                }\r\n                cdgData = cdgHttpRequest.responseText;\r\n                cdgHttpRequest = null;\r\n            }\r\n        }\r\n\r\n        function handleAudioError() {\r\n            if (audioPlayer.error) {\r\n                var error_result = audioPlayer.error.code ? audioPlayer.error.code : audioPlayer.error;\r\n                throw new Error(\"The audio control fired an error event. Could be: \" + error_result);\r\n            }\r\n        }\r\n\r\n        function updatePlayPosition() {\r\n            if (cdgData != null) {\r\n                var play_position = Math.floor(audioPlayer.currentTime * 300),\r\n                    current_pack = cdgDecoder.get_current_pack(),\r\n                    position_to_play;\r\n                play_position = (play_position < 0) ? 0 : play_position;\r\n                // Render from the beginning of the stream if a reverse seek of more than one second occurred.\r\n                if (play_position < (current_pack - 300)) {\r\n                    cdgDecoder.reset_cdg_state();\r\n                    current_pack = 0;\r\n                }\r\n                position_to_play = current_pack + 6;\r\n                // Jump to the actual play position if it's ahead of our calculated smoothed position.\r\n                position_to_play = (play_position > position_to_play) ? play_position : position_to_play;\r\n                // Check if we should render any packs, and do so if needed.\r\n                if (position_to_play > current_pack) {\r\n                    cdgDecoder.decode_packs(cdgData, position_to_play);\r\n                    cdgDecoder.redraw_canvas();\r\n                }\r\n            }\r\n        }\r\n\r\n        function setCDGInterval() {\r\n            cdgIntervalID = setInterval(updatePlayPosition, 20);\r\n        }\r\n\r\n        function clearCDGInterval() {\r\n            clearInterval(cdgIntervalID);\r\n        }\r\n\r\n        function play() {\r\n            audioPlayer.play();\r\n        }\r\n\r\n        function pause() {\r\n            audioPlayer.pause();\r\n        }\r\n\r\n        function stop() {\r\n            audioPlayer.pause();\r\n            audioPlayer.currentTime = 0;\r\n        }\r\n\r\n        function parseOptions(options) {\r\n            if (!options || Array.isArray(options) || (typeof options !== 'string' && typeof options !== 'object')) {\r\n                throw new Error('No track information specified, nothing to load!');\r\n            }\r\n            var audioFilePrefix,\r\n                cdgFilePrefix,\r\n                mediaPath = defaults.mediaPath,\r\n                audioFormat = defaults.audioFormat,\r\n                cdgFileExtension = defaults.cdgFileExtension;\r\n            if (typeof options === 'object') {\r\n                if (!options.audioFilePrefix) {\r\n                    throw new Error('No audioFilePrefix property defined, nothing to load!');\r\n                } else {\r\n                    audioFilePrefix = options.audioFilePrefix;\r\n                }\r\n                cdgFilePrefix = options.cdgFilePrefix ? options.cdgFilePrefix : options.audioFilePrefix;\r\n                if (options.mediaPath) {\r\n                    mediaPath = options.mediaPath;\r\n                }\r\n                if (options.audioFormat) {\r\n                    if (!audioTypes[options.audioFormat]) {\r\n                        throw new Error('Unsupported audio format specified');\r\n                    }\r\n                    audioFormat = options.audioFormat;\r\n                }\r\n                if (options.cdgFileExtension) {\r\n                    cdgFileExtension = options.cdgFileExtension;\r\n                }\r\n            } else {\r\n                audioFilePrefix = cdgFilePrefix = options;\r\n            }\r\n\r\n            return {\r\n                audioFilePrefix: audioFilePrefix,\r\n                cdgFilePrefix: cdgFilePrefix,\r\n                mediaPath: mediaPath,\r\n                audioFormat: audioFormat,\r\n                cdgFileExtension: cdgFileExtension\r\n            }\r\n        }\r\n\r\n        function loadTrack(options) {\r\n            var trackInfo = parseOptions(options);\r\n            clearCDGInterval();\r\n            cdgDecoder.reset_cdg_state();\r\n            cdgDecoder.redraw_canvas();\r\n            cdgData = null;\r\n            cdgHttpRequest = new XMLHttpRequest();\r\n            cdgHttpRequest.onreadystatechange = handleCDGHttpRequest;\r\n            cdgHttpRequest.open(\"GET\", trackInfo.mediaPath + trackInfo.cdgFilePrefix + \".\" + trackInfo.cdgFileExtension, true);\r\n            cdgHttpRequest.setRequestHeader(\"Content-Type\", \"text/html\");\r\n            cdgHttpRequest.send();\r\n            if (audioSourceElement == null) {\r\n                audioSourceElement = document.createElement(\"source\");\r\n            }\r\n            audioSourceElement.type = audioTypes[trackInfo.audioFormat];\r\n            audioSourceElement.src = trackInfo.mediaPath + trackInfo.audioFilePrefix + \".\" + trackInfo.audioFormat;\r\n            audioPlayer.appendChild(audioSourceElement);\r\n            audioPlayer.load();\r\n            return this;\r\n        }\r\n\r\n        function init(containerId, initOptions) {\r\n            if (!containerId) {\r\n                throw new Error(\"Required initialisation parameter missing.\")\r\n            }\r\n            var containerEl = document.getElementById(containerId),\r\n                borderEl = document.createElement(\"div\"),\r\n                canvasEl = document.createElement(\"canvas\");\r\n            audioPlayer = document.createElement(\"audio\");\r\n            borderEl.id = containerId + \"-border\";\r\n            borderEl.className = \"cdg-border\";\r\n            canvasEl.id = containerId + \"-canvas\";\r\n            canvasEl.width = \"288\";\r\n            canvasEl.height = \"192\";\r\n            canvasEl.className = \"cdg-canvas\";\r\n            audioPlayer.id = containerId + \"-audio\";\r\n            audioPlayer.className = \"cdg-audio\";\r\n            borderEl.appendChild(canvasEl);\r\n            containerEl.appendChild(borderEl);\r\n            containerEl.appendChild(audioPlayer);\r\n            audioPlayer.style.width = canvasEl.offsetWidth + \"px\";\r\n            audioPlayer.controls = (initOptions && initOptions.showControls) != false;\r\n            audioPlayer.autoplay = (initOptions && initOptions.autoplay) != false;\r\n            audioPlayer.addEventListener(\"error\", handleAudioError, true);\r\n            audioPlayer.addEventListener(\"play\", setCDGInterval, true);\r\n            audioPlayer.addEventListener(\"pause\", clearCDGInterval, true);\r\n            audioPlayer.addEventListener(\"ended\", clearCDGInterval, true);\r\n            audioPlayer.addEventListener(\"abort\", clearCDGInterval, true);\r\n            cdgDecoder = new CDGDecoder(canvasEl, borderEl);\r\n        }\r\n\r\n        init(containerId, initOptions);\r\n\r\n        // Bind the public functions to member variables.\r\n        this.loadTrack = loadTrack;\r\n        this.play = play;\r\n        this.stop = stop;\r\n        this.pause = pause;\r\n    }\r\n\r\n    return {\r\n        init: function(containerId, initOptions) {\r\n            return new CDGPlayer(containerId, initOptions);\r\n        }\r\n    }\r\n});\r\n\ndefine(\"cdg.js\", function(){});\n\n"],"sourceRoot":"/source/"}